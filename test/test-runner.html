<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daggerheart Statblock Importer - Test Runner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-case {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f9f9f9;
        }
        
        .test-input {
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .test-output {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
        }
        
        .button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        .button:hover {
            background: #005a87;
        }
        
        .success {
            color: #28a745;
        }
        
        .error {
            color: #dc3545;
        }
        
        .warning {
            color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Daggerheart Statblock Importer - Test Runner</h1>
        <p>This page allows you to test the statblock parser independently of Foundry VTT.</p>
        
        <div class="test-case">
            <h3>Manual Test</h3>
            <textarea class="test-input" id="manualInput" placeholder="Paste your statblock here...">ACID BURROWER T1 Solo
A home-sized insect with digging claws and acidic blood.
Difficulty: 14
Attack: +3
Experience: Tremor Sense +2
Motives & Tactics: Burrow, Drag away, Feed, Reposition

FEATURES
Relentless (2) - Passive
The Burrower can be spotlighted up to three times per GM turn. Spend Fear as usual to spotlight them.
Earth Eruption - Action
Mark a Stress to have the Burrower burst out of the ground. Make an attack against all targets in front of the Burrower within Close range. Targets the Burrower succeeds against take 2d6 physical damage and must mark an Armor Slot without receiving its benefits. If they can't mark an Armor Slot, they must mark an additional HP and you gain a Fear.
Acid Bath - Reaction
When the Burrower takes Severe damage, all creatures within Close range are bathed in their acidic blood, taking 1d10 physical damage. This splash covers the ground within Very Close range with blood, and all creatures other than the Burrower who move through it take 1d6 physical damage.

HP & STRESS
MINOR HP [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] 8 MAJOR HP [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] 15 SEVERE HP [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]
STRESS [ ] [ ] [ ]</textarea>
            <br>
            <button class="button" onclick="testManualInput()">Parse Statblock</button>
            <button class="button" onclick="clearOutput()">Clear Output</button>
            <div class="test-output" id="manualOutput"></div>
        </div>
        
        <div class="test-case">
            <h3>Automated Tests</h3>
            <button class="button" onclick="runAutomatedTests()">Run All Tests</button>
            <div class="test-output" id="automatedOutput"></div>
        </div>
    </div>

    <!-- Include the parser modules -->
    <script type="module">
        // Mock game object for testing
        window.game = {
            i18n: {
                localize: (key) => key,
                format: (key, data) => key + ' ' + JSON.stringify(data)
            },
            settings: {
                get: () => true // Enable debug mode for testing
            }
        };

        // Import the parser
        import('./test-cases.js').then(module => {
            window.TEST_CASES = module.TEST_CASES;
            window.runTests = module.runTests;
        });
        
        // Simple StatblockParser for testing (without Foundry dependencies)
        class StatblockParser {
            constructor() {
                this.debugMode = true;
            }
            
            async parse(text) {
                if (!text || typeof text !== 'string') {
                    throw new Error('Empty input provided');
                }
                
                const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                
                if (lines.length === 0) {
                    throw new Error('Empty input provided');
                }
                
                const result = {
                    name: '',
                    type: 'adversary',
                    tier: 1,
                    subtype: '',
                    description: '',
                    difficulty: 10,
                    attack: 0,
                    experience: '',
                    motivesAndTactics: '',
                    features: [],
                    hitPoints: { minor: 0, major: 0, severe: 0 },
                    stress: 0,
                    resistances: [],
                    immunities: [],
                    vulnerabilities: []
                };
                
                let currentSection = 'header';
                let currentFeature = null;
                let lineIndex = 0;
                
                for (const line of lines) {
                    lineIndex++;
                    
                    if (!line.trim()) continue;
                    
                    if (currentSection === 'header') {
                        if (this._parseNameAndType(line, result)) {
                            continue;
                        } else if (this._parseDescription(line, result)) {
                            continue;
                        } else if (this._parseBasicStats(line, result)) {
                            continue;
                        } else if (line.toUpperCase().includes('FEATURES')) {
                            currentSection = 'features';
                            continue;
                        } else if (line.toUpperCase().includes('HP') && line.toUpperCase().includes('STRESS')) {
                            currentSection = 'hp_stress';
                            this._parseHPStress(line, result);
                            continue;
                        }
                    } else if (currentSection === 'features') {
                        if (line.toUpperCase().includes('HP') && line.toUpperCase().includes('STRESS')) {
                            currentSection = 'hp_stress';
                            this._parseHPStress(line, result);
                            continue;
                        }
                        
                        const featureMatch = this._parseFeatureHeader(line);
                        if (featureMatch) {
                            if (currentFeature) {
                                result.features.push(currentFeature);
                            }
                            
                            currentFeature = {
                                name: featureMatch.name,
                                type: featureMatch.type.toLowerCase(),
                                value: featureMatch.value || '',
                                description: ''
                            };
                        } else if (currentFeature) {
                            if (currentFeature.description) {
                                currentFeature.description += ' ';
                            }
                            currentFeature.description += line;
                        }
                    } else if (currentSection === 'hp_stress') {
                        this._parseHPStress(line, result);
                    }
                }
                
                if (currentFeature) {
                    result.features.push(currentFeature);
                }
                
                if (!result.name) {
                    throw new Error('Could not find creature name in statblock');
                }
                
                return result;
            }
            
            _parseNameAndType(line, result) {
                const nameTypeMatch = line.match(/^(.+?)\s+(T(\d+)\s+(.+))$/i);
                if (nameTypeMatch) {
                    result.name = nameTypeMatch[1].trim();
                    result.tier = parseInt(nameTypeMatch[3]) || 1;
                    result.subtype = nameTypeMatch[4].trim();
                    return true;
                }
                
                if (!result.name && line.length > 0 && !line.includes(':')) {
                    result.name = line.trim();
                    return true;
                }
                
                return false;
            }
            
            _parseDescription(line, result) {
                if (result.name && !result.description && !line.includes(':') && !line.match(/^(Difficulty|Attack|Experience|Motives)/i)) {
                    result.description = line.trim();
                    return true;
                }
                return false;
            }
            
            _parseBasicStats(line, result) {
                const difficultyMatch = line.match(/^Difficulty:\s*(\d+)/i);
                if (difficultyMatch) {
                    result.difficulty = parseInt(difficultyMatch[1]);
                    return true;
                }
                
                const attackMatch = line.match(/^Attack:\s*([+-]?\d+)/i);
                if (attackMatch) {
                    result.attack = parseInt(attackMatch[1]);
                    return true;
                }
                
                const experienceMatch = line.match(/^Experience:\s*(.+)/i);
                if (experienceMatch) {
                    result.experience = experienceMatch[1].trim();
                    return true;
                }
                
                const motivesMatch = line.match(/^Motives\s*&\s*Tactics:\s*(.+)/i);
                if (motivesMatch) {
                    result.motivesAndTactics = motivesMatch[1].trim();
                    return true;
                }
                
                return false;
            }
            
            _parseFeatureHeader(line) {
                const featureMatch = line.match(/^(.+?)\s*(?:\(([^)]+)\))?\s*-\s*(Passive|Action|Reaction)$/i);
                if (featureMatch) {
                    return {
                        name: featureMatch[1].trim(),
                        value: featureMatch[2] || '',
                        type: featureMatch[3].trim()
                    };
                }
                return null;
            }
            
            _parseHPStress(line, result) {
                const minorHPMatch = line.match(/MINOR\s+HP[^\d]*(\d+)/i);
                if (minorHPMatch) {
                    result.hitPoints.minor = parseInt(minorHPMatch[1]);
                }
                
                const majorHPMatch = line.match(/MAJOR\s+HP[^\d]*(\d+)/i);
                if (majorHPMatch) {
                    result.hitPoints.major = parseInt(majorHPMatch[1]);
                }
                
                const severeHPMatch = line.match(/SEVERE\s+HP[^\d]*(\d+)/i);
                if (severeHPMatch) {
                    result.hitPoints.severe = parseInt(severeHPMatch[1]);
                }
                
                const stressMatch = line.match(/STRESS[^\d]*(\d+)/i);
                if (stressMatch) {
                    result.stress = parseInt(stressMatch[1]);
                }
            }
        }
        
        window.StatblockParser = StatblockParser;
    </script>

    <script>
        function testManualInput() {
            const input = document.getElementById('manualInput').value;
            const output = document.getElementById('manualOutput');
            
            try {
                const parser = new StatblockParser();
                parser.parse(input).then(result => {
                    output.innerHTML = '<span class="success">✅ Parsing successful!</span>\n\n' + 
                                     JSON.stringify(result, null, 2);
                }).catch(error => {
                    output.innerHTML = '<span class="error">❌ Parsing failed:</span>\n' + error.message;
                });
            } catch (error) {
                output.innerHTML = '<span class="error">❌ Error:</span>\n' + error.message;
            }
        }
        
        function clearOutput() {
            document.getElementById('manualOutput').innerHTML = '';
            document.getElementById('automatedOutput').innerHTML = '';
        }
        
        function runAutomatedTests() {
            const output = document.getElementById('automatedOutput');
            output.innerHTML = '<span class="warning">Running tests...</span>';
            
            // Simple test runner
            const testCases = {
                acidBurrower: {
                    input: `ACID BURROWER T1 Solo
A home-sized insect with digging claws and acidic blood.
Difficulty: 14
Attack: +3
Experience: Tremor Sense +2
Motives & Tactics: Burrow, Drag away, Feed, Reposition

FEATURES
Relentless (2) - Passive
The Burrower can be spotlighted up to three times per GM turn.

HP & STRESS
MINOR HP [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] 8 MAJOR HP [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] 15
STRESS [ ] [ ] [ ]`,
                    expected: {
                        name: 'ACID BURROWER',
                        difficulty: 14,
                        attack: 3
                    }
                }
            };
            
            let results = [];
            const parser = new StatblockParser();
            
            Promise.all(Object.entries(testCases).map(async ([name, testCase]) => {
                try {
                    const result = await parser.parse(testCase.input);
                    const expected = testCase.expected;
                    
                    let passed = true;
                    let errors = [];
                    
                    if (result.name !== expected.name) {
                        passed = false;
                        errors.push(`Name: expected "${expected.name}", got "${result.name}"`);
                    }
                    
                    if (result.difficulty !== expected.difficulty) {
                        passed = false;
                        errors.push(`Difficulty: expected ${expected.difficulty}, got ${result.difficulty}`);
                    }
                    
                    if (result.attack !== expected.attack) {
                        passed = false;
                        errors.push(`Attack: expected ${expected.attack}, got ${result.attack}`);
                    }
                    
                    return {
                        name,
                        passed,
                        errors,
                        result
                    };
                } catch (error) {
                    return {
                        name,
                        passed: false,
                        errors: [error.message],
                        result: null
                    };
                }
            })).then(testResults => {
                let outputText = '';
                let passed = 0;
                let failed = 0;
                
                testResults.forEach(test => {
                    if (test.passed) {
                        passed++;
                        outputText += `<span class="success">✅ ${test.name}: PASSED</span>\n`;
                    } else {
                        failed++;
                        outputText += `<span class="error">❌ ${test.name}: FAILED</span>\n`;
                        test.errors.forEach(error => {
                            outputText += `  - ${error}\n`;
                        });
                    }
                });
                
                outputText += `\n=== Results ===\n`;
                outputText += `Passed: ${passed}\n`;
                outputText += `Failed: ${failed}\n`;
                outputText += `Total: ${passed + failed}`;
                
                output.innerHTML = outputText;
            });
        }
    </script>
</body>
</html>

